{"ast":null,"code":"import { useState, useRef, useCallback } from 'react';\nimport { HoverActionTypes } from '../utils/constants.js';\nimport { indexOfNode } from '../utils/utils.js';\nconst useItems = (menuRef, focusRef) => {\n  const [hoverItem, setHoverItem] = useState();\n  const stateRef = useRef({\n    items: [],\n    hoverIndex: -1,\n    sorted: false\n  });\n  const mutableState = stateRef.current;\n  const updateItems = useCallback((item, isMounted) => {\n    const {\n      items\n    } = mutableState;\n    if (!item) {\n      mutableState.items = [];\n    } else if (isMounted) {\n      items.push(item);\n    } else {\n      const index = items.indexOf(item);\n      if (index > -1) {\n        items.splice(index, 1);\n        if (item.contains(document.activeElement)) {\n          focusRef.current.focus();\n          setHoverItem();\n        }\n      }\n    }\n    mutableState.hoverIndex = -1;\n    mutableState.sorted = false;\n  }, [mutableState, focusRef]);\n  const dispatch = useCallback((actionType, item, nextIndex) => {\n    const {\n      items,\n      hoverIndex\n    } = mutableState;\n    const sortItems = () => {\n      if (mutableState.sorted) return;\n      const orderedNodes = menuRef.current.querySelectorAll('.szh-menu__item');\n      items.sort((a, b) => indexOfNode(orderedNodes, a) - indexOfNode(orderedNodes, b));\n      mutableState.sorted = true;\n    };\n    let index = -1,\n      newItem = undefined;\n    switch (actionType) {\n      case HoverActionTypes.RESET:\n        break;\n      case HoverActionTypes.SET:\n        newItem = item;\n        break;\n      case HoverActionTypes.UNSET:\n        newItem = prevItem => prevItem === item ? undefined : prevItem;\n        break;\n      case HoverActionTypes.FIRST:\n        sortItems();\n        index = 0;\n        newItem = items[index];\n        break;\n      case HoverActionTypes.LAST:\n        sortItems();\n        index = items.length - 1;\n        newItem = items[index];\n        break;\n      case HoverActionTypes.SET_INDEX:\n        sortItems();\n        index = nextIndex;\n        newItem = items[index];\n        break;\n      case HoverActionTypes.INCREASE:\n        sortItems();\n        index = hoverIndex;\n        if (index < 0) index = items.indexOf(item);\n        index++;\n        if (index >= items.length) index = 0;\n        newItem = items[index];\n        break;\n      case HoverActionTypes.DECREASE:\n        sortItems();\n        index = hoverIndex;\n        if (index < 0) index = items.indexOf(item);\n        index--;\n        if (index < 0) index = items.length - 1;\n        newItem = items[index];\n        break;\n      default:\n        if (process.env.NODE_ENV !== 'production') throw new Error(`[React-Menu] Unknown hover action type: ${actionType}`);\n    }\n    if (!newItem) index = -1;\n    setHoverItem(newItem);\n    mutableState.hoverIndex = index;\n  }, [menuRef, mutableState]);\n  return {\n    hoverItem,\n    dispatch,\n    updateItems\n  };\n};\nexport { useItems };","map":{"version":3,"names":["useState","useRef","useCallback","HoverActionTypes","indexOfNode","useItems","menuRef","focusRef","hoverItem","setHoverItem","stateRef","items","hoverIndex","sorted","mutableState","current","updateItems","item","isMounted","push","index","indexOf","splice","contains","document","activeElement","focus","dispatch","actionType","nextIndex","sortItems","orderedNodes","querySelectorAll","sort","a","b","newItem","undefined","RESET","SET","UNSET","prevItem","FIRST","LAST","length","SET_INDEX","INCREASE","DECREASE","process","env","NODE_ENV","Error"],"sources":["/Users/hamzaaslam/VSCode/autode/client/node_modules/@szhsin/react-menu/dist/es/hooks/useItems.js"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\nimport { HoverActionTypes } from '../utils/constants.js';\nimport { indexOfNode } from '../utils/utils.js';\n\nconst useItems = (menuRef, focusRef) => {\n  const [hoverItem, setHoverItem] = useState();\n  const stateRef = useRef({\n    items: [],\n    hoverIndex: -1,\n    sorted: false\n  });\n  const mutableState = stateRef.current;\n  const updateItems = useCallback((item, isMounted) => {\n    const {\n      items\n    } = mutableState;\n    if (!item) {\n      mutableState.items = [];\n    } else if (isMounted) {\n      items.push(item);\n    } else {\n      const index = items.indexOf(item);\n      if (index > -1) {\n        items.splice(index, 1);\n        if (item.contains(document.activeElement)) {\n          focusRef.current.focus();\n          setHoverItem();\n        }\n      }\n    }\n    mutableState.hoverIndex = -1;\n    mutableState.sorted = false;\n  }, [mutableState, focusRef]);\n  const dispatch = useCallback((actionType, item, nextIndex) => {\n    const {\n      items,\n      hoverIndex\n    } = mutableState;\n    const sortItems = () => {\n      if (mutableState.sorted) return;\n      const orderedNodes = menuRef.current.querySelectorAll('.szh-menu__item');\n      items.sort((a, b) => indexOfNode(orderedNodes, a) - indexOfNode(orderedNodes, b));\n      mutableState.sorted = true;\n    };\n    let index = -1,\n      newItem = undefined;\n    switch (actionType) {\n      case HoverActionTypes.RESET:\n        break;\n      case HoverActionTypes.SET:\n        newItem = item;\n        break;\n      case HoverActionTypes.UNSET:\n        newItem = prevItem => prevItem === item ? undefined : prevItem;\n        break;\n      case HoverActionTypes.FIRST:\n        sortItems();\n        index = 0;\n        newItem = items[index];\n        break;\n      case HoverActionTypes.LAST:\n        sortItems();\n        index = items.length - 1;\n        newItem = items[index];\n        break;\n      case HoverActionTypes.SET_INDEX:\n        sortItems();\n        index = nextIndex;\n        newItem = items[index];\n        break;\n      case HoverActionTypes.INCREASE:\n        sortItems();\n        index = hoverIndex;\n        if (index < 0) index = items.indexOf(item);\n        index++;\n        if (index >= items.length) index = 0;\n        newItem = items[index];\n        break;\n      case HoverActionTypes.DECREASE:\n        sortItems();\n        index = hoverIndex;\n        if (index < 0) index = items.indexOf(item);\n        index--;\n        if (index < 0) index = items.length - 1;\n        newItem = items[index];\n        break;\n      default:\n        if (process.env.NODE_ENV !== 'production') throw new Error(`[React-Menu] Unknown hover action type: ${actionType}`);\n    }\n    if (!newItem) index = -1;\n    setHoverItem(newItem);\n    mutableState.hoverIndex = index;\n  }, [menuRef, mutableState]);\n  return {\n    hoverItem,\n    dispatch,\n    updateItems\n  };\n};\n\nexport { useItems };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}