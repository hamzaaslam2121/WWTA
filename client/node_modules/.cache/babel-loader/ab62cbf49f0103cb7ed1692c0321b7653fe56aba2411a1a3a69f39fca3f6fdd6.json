{"ast":null,"code":"import { placeArrowVertical } from './placeArrowVertical.js';\nconst placeLeftorRight = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeLeftorRightY,\n  placeLeftX,\n  placeRightX,\n  getLeftOverflow,\n  getRightOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction;\n  let y = placeLeftorRightY;\n  if (position !== 'initial') {\n    y = confineVertically(y);\n    if (position === 'anchor') {\n      y = Math.min(y, anchorRect.bottom - containerRect.top);\n      y = Math.max(y, anchorRect.top - containerRect.top - menuRect.height);\n    }\n  }\n  let x, leftOverflow, rightOverflow;\n  if (computedDirection === 'left') {\n    x = placeLeftX;\n    if (position !== 'initial') {\n      leftOverflow = getLeftOverflow(x);\n      if (leftOverflow < 0) {\n        rightOverflow = getRightOverflow(placeRightX);\n        if (rightOverflow <= 0 || -leftOverflow > rightOverflow) {\n          x = placeRightX;\n          computedDirection = 'right';\n        }\n      }\n    }\n  } else {\n    x = placeRightX;\n    if (position !== 'initial') {\n      rightOverflow = getRightOverflow(x);\n      if (rightOverflow > 0) {\n        leftOverflow = getLeftOverflow(placeLeftX);\n        if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n          x = placeLeftX;\n          computedDirection = 'left';\n        }\n      }\n    }\n  }\n  if (position === 'auto') x = confineHorizontally(x);\n  const arrowY = arrow ? placeArrowVertical({\n    menuY: y,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowY,\n    x,\n    y,\n    computedDirection\n  };\n};\nexport { placeLeftorRight };","map":{"version":3,"names":["placeArrowVertical","placeLeftorRight","anchorRect","containerRect","menuRect","placeLeftorRightY","placeLeftX","placeRightX","getLeftOverflow","getRightOverflow","confineHorizontally","confineVertically","arrowRef","arrow","direction","position","computedDirection","y","Math","min","bottom","top","max","height","x","leftOverflow","rightOverflow","arrowY","menuY","undefined"],"sources":["/Users/hamzaaslam/VSCode/autode/client/node_modules/@szhsin/react-menu/dist/es/positionUtils/placeLeftorRight.js"],"sourcesContent":["import { placeArrowVertical } from './placeArrowVertical.js';\n\nconst placeLeftorRight = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeLeftorRightY,\n  placeLeftX,\n  placeRightX,\n  getLeftOverflow,\n  getRightOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction;\n  let y = placeLeftorRightY;\n  if (position !== 'initial') {\n    y = confineVertically(y);\n    if (position === 'anchor') {\n      y = Math.min(y, anchorRect.bottom - containerRect.top);\n      y = Math.max(y, anchorRect.top - containerRect.top - menuRect.height);\n    }\n  }\n  let x, leftOverflow, rightOverflow;\n  if (computedDirection === 'left') {\n    x = placeLeftX;\n    if (position !== 'initial') {\n      leftOverflow = getLeftOverflow(x);\n      if (leftOverflow < 0) {\n        rightOverflow = getRightOverflow(placeRightX);\n        if (rightOverflow <= 0 || -leftOverflow > rightOverflow) {\n          x = placeRightX;\n          computedDirection = 'right';\n        }\n      }\n    }\n  } else {\n    x = placeRightX;\n    if (position !== 'initial') {\n      rightOverflow = getRightOverflow(x);\n      if (rightOverflow > 0) {\n        leftOverflow = getLeftOverflow(placeLeftX);\n        if (leftOverflow >= 0 || -leftOverflow < rightOverflow) {\n          x = placeLeftX;\n          computedDirection = 'left';\n        }\n      }\n    }\n  }\n  if (position === 'auto') x = confineHorizontally(x);\n  const arrowY = arrow ? placeArrowVertical({\n    menuY: y,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowY,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nexport { placeLeftorRight };\n"],"mappings":"AAAA,SAASA,kBAAkB,QAAQ,yBAAyB;AAE5D,MAAMC,gBAAgB,GAAGA,CAAC;EACxBC,UAAU;EACVC,aAAa;EACbC,QAAQ;EACRC,iBAAiB;EACjBC,UAAU;EACVC,WAAW;EACXC,eAAe;EACfC,gBAAgB;EAChBC,mBAAmB;EACnBC,iBAAiB;EACjBC,QAAQ;EACRC,KAAK;EACLC,SAAS;EACTC;AACF,CAAC,KAAK;EACJ,IAAIC,iBAAiB,GAAGF,SAAS;EACjC,IAAIG,CAAC,GAAGZ,iBAAiB;EACzB,IAAIU,QAAQ,KAAK,SAAS,EAAE;IAC1BE,CAAC,GAAGN,iBAAiB,CAACM,CAAC,CAAC;IACxB,IAAIF,QAAQ,KAAK,QAAQ,EAAE;MACzBE,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACF,CAAC,EAAEf,UAAU,CAACkB,MAAM,GAAGjB,aAAa,CAACkB,GAAG,CAAC;MACtDJ,CAAC,GAAGC,IAAI,CAACI,GAAG,CAACL,CAAC,EAAEf,UAAU,CAACmB,GAAG,GAAGlB,aAAa,CAACkB,GAAG,GAAGjB,QAAQ,CAACmB,MAAM,CAAC;IACvE;EACF;EACA,IAAIC,CAAC,EAAEC,YAAY,EAAEC,aAAa;EAClC,IAAIV,iBAAiB,KAAK,MAAM,EAAE;IAChCQ,CAAC,GAAGlB,UAAU;IACd,IAAIS,QAAQ,KAAK,SAAS,EAAE;MAC1BU,YAAY,GAAGjB,eAAe,CAACgB,CAAC,CAAC;MACjC,IAAIC,YAAY,GAAG,CAAC,EAAE;QACpBC,aAAa,GAAGjB,gBAAgB,CAACF,WAAW,CAAC;QAC7C,IAAImB,aAAa,IAAI,CAAC,IAAI,CAACD,YAAY,GAAGC,aAAa,EAAE;UACvDF,CAAC,GAAGjB,WAAW;UACfS,iBAAiB,GAAG,OAAO;QAC7B;MACF;IACF;EACF,CAAC,MAAM;IACLQ,CAAC,GAAGjB,WAAW;IACf,IAAIQ,QAAQ,KAAK,SAAS,EAAE;MAC1BW,aAAa,GAAGjB,gBAAgB,CAACe,CAAC,CAAC;MACnC,IAAIE,aAAa,GAAG,CAAC,EAAE;QACrBD,YAAY,GAAGjB,eAAe,CAACF,UAAU,CAAC;QAC1C,IAAImB,YAAY,IAAI,CAAC,IAAI,CAACA,YAAY,GAAGC,aAAa,EAAE;UACtDF,CAAC,GAAGlB,UAAU;UACdU,iBAAiB,GAAG,MAAM;QAC5B;MACF;IACF;EACF;EACA,IAAID,QAAQ,KAAK,MAAM,EAAES,CAAC,GAAGd,mBAAmB,CAACc,CAAC,CAAC;EACnD,MAAMG,MAAM,GAAGd,KAAK,GAAGb,kBAAkB,CAAC;IACxC4B,KAAK,EAAEX,CAAC;IACRL,QAAQ;IACRV,UAAU;IACVC,aAAa;IACbC;EACF,CAAC,CAAC,GAAGyB,SAAS;EACd,OAAO;IACLF,MAAM;IACNH,CAAC;IACDP,CAAC;IACDD;EACF,CAAC;AACH,CAAC;AAED,SAASf,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}