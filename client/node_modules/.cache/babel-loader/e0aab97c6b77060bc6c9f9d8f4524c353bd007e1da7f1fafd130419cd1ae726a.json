{"ast":null,"code":"import { placeArrowHorizontal } from './placeArrowHorizontal.js';\nconst placeToporBottom = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeToporBottomX,\n  placeTopY,\n  placeBottomY,\n  getTopOverflow,\n  getBottomOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction === 'top' ? 'top' : 'bottom';\n  let x = placeToporBottomX;\n  if (position !== 'initial') {\n    x = confineHorizontally(x);\n    if (position === 'anchor') {\n      x = Math.min(x, anchorRect.right - containerRect.left);\n      x = Math.max(x, anchorRect.left - containerRect.left - menuRect.width);\n    }\n  }\n  let y, topOverflow, bottomOverflow;\n  if (computedDirection === 'top') {\n    y = placeTopY;\n    if (position !== 'initial') {\n      topOverflow = getTopOverflow(y);\n      if (topOverflow < 0) {\n        bottomOverflow = getBottomOverflow(placeBottomY);\n        if (bottomOverflow <= 0 || -topOverflow > bottomOverflow) {\n          y = placeBottomY;\n          computedDirection = 'bottom';\n        }\n      }\n    }\n  } else {\n    y = placeBottomY;\n    if (position !== 'initial') {\n      bottomOverflow = getBottomOverflow(y);\n      if (bottomOverflow > 0) {\n        topOverflow = getTopOverflow(placeTopY);\n        if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n          y = placeTopY;\n          computedDirection = 'top';\n        }\n      }\n    }\n  }\n  if (position === 'auto') y = confineVertically(y);\n  const arrowX = arrow ? placeArrowHorizontal({\n    menuX: x,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowX,\n    x,\n    y,\n    computedDirection\n  };\n};\nexport { placeToporBottom };","map":{"version":3,"names":["placeArrowHorizontal","placeToporBottom","anchorRect","containerRect","menuRect","placeToporBottomX","placeTopY","placeBottomY","getTopOverflow","getBottomOverflow","confineHorizontally","confineVertically","arrowRef","arrow","direction","position","computedDirection","x","Math","min","right","left","max","width","y","topOverflow","bottomOverflow","arrowX","menuX","undefined"],"sources":["/Users/hamzaaslam/VSCode/autode/client/node_modules/@szhsin/react-menu/dist/es/positionUtils/placeToporBottom.js"],"sourcesContent":["import { placeArrowHorizontal } from './placeArrowHorizontal.js';\n\nconst placeToporBottom = ({\n  anchorRect,\n  containerRect,\n  menuRect,\n  placeToporBottomX,\n  placeTopY,\n  placeBottomY,\n  getTopOverflow,\n  getBottomOverflow,\n  confineHorizontally,\n  confineVertically,\n  arrowRef,\n  arrow,\n  direction,\n  position\n}) => {\n  let computedDirection = direction === 'top' ? 'top' : 'bottom';\n  let x = placeToporBottomX;\n  if (position !== 'initial') {\n    x = confineHorizontally(x);\n    if (position === 'anchor') {\n      x = Math.min(x, anchorRect.right - containerRect.left);\n      x = Math.max(x, anchorRect.left - containerRect.left - menuRect.width);\n    }\n  }\n  let y, topOverflow, bottomOverflow;\n  if (computedDirection === 'top') {\n    y = placeTopY;\n    if (position !== 'initial') {\n      topOverflow = getTopOverflow(y);\n      if (topOverflow < 0) {\n        bottomOverflow = getBottomOverflow(placeBottomY);\n        if (bottomOverflow <= 0 || -topOverflow > bottomOverflow) {\n          y = placeBottomY;\n          computedDirection = 'bottom';\n        }\n      }\n    }\n  } else {\n    y = placeBottomY;\n    if (position !== 'initial') {\n      bottomOverflow = getBottomOverflow(y);\n      if (bottomOverflow > 0) {\n        topOverflow = getTopOverflow(placeTopY);\n        if (topOverflow >= 0 || -topOverflow < bottomOverflow) {\n          y = placeTopY;\n          computedDirection = 'top';\n        }\n      }\n    }\n  }\n  if (position === 'auto') y = confineVertically(y);\n  const arrowX = arrow ? placeArrowHorizontal({\n    menuX: x,\n    arrowRef,\n    anchorRect,\n    containerRect,\n    menuRect\n  }) : undefined;\n  return {\n    arrowX,\n    x,\n    y,\n    computedDirection\n  };\n};\n\nexport { placeToporBottom };\n"],"mappings":"AAAA,SAASA,oBAAoB,QAAQ,2BAA2B;AAEhE,MAAMC,gBAAgB,GAAGA,CAAC;EACxBC,UAAU;EACVC,aAAa;EACbC,QAAQ;EACRC,iBAAiB;EACjBC,SAAS;EACTC,YAAY;EACZC,cAAc;EACdC,iBAAiB;EACjBC,mBAAmB;EACnBC,iBAAiB;EACjBC,QAAQ;EACRC,KAAK;EACLC,SAAS;EACTC;AACF,CAAC,KAAK;EACJ,IAAIC,iBAAiB,GAAGF,SAAS,KAAK,KAAK,GAAG,KAAK,GAAG,QAAQ;EAC9D,IAAIG,CAAC,GAAGZ,iBAAiB;EACzB,IAAIU,QAAQ,KAAK,SAAS,EAAE;IAC1BE,CAAC,GAAGP,mBAAmB,CAACO,CAAC,CAAC;IAC1B,IAAIF,QAAQ,KAAK,QAAQ,EAAE;MACzBE,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACF,CAAC,EAAEf,UAAU,CAACkB,KAAK,GAAGjB,aAAa,CAACkB,IAAI,CAAC;MACtDJ,CAAC,GAAGC,IAAI,CAACI,GAAG,CAACL,CAAC,EAAEf,UAAU,CAACmB,IAAI,GAAGlB,aAAa,CAACkB,IAAI,GAAGjB,QAAQ,CAACmB,KAAK,CAAC;IACxE;EACF;EACA,IAAIC,CAAC,EAAEC,WAAW,EAAEC,cAAc;EAClC,IAAIV,iBAAiB,KAAK,KAAK,EAAE;IAC/BQ,CAAC,GAAGlB,SAAS;IACb,IAAIS,QAAQ,KAAK,SAAS,EAAE;MAC1BU,WAAW,GAAGjB,cAAc,CAACgB,CAAC,CAAC;MAC/B,IAAIC,WAAW,GAAG,CAAC,EAAE;QACnBC,cAAc,GAAGjB,iBAAiB,CAACF,YAAY,CAAC;QAChD,IAAImB,cAAc,IAAI,CAAC,IAAI,CAACD,WAAW,GAAGC,cAAc,EAAE;UACxDF,CAAC,GAAGjB,YAAY;UAChBS,iBAAiB,GAAG,QAAQ;QAC9B;MACF;IACF;EACF,CAAC,MAAM;IACLQ,CAAC,GAAGjB,YAAY;IAChB,IAAIQ,QAAQ,KAAK,SAAS,EAAE;MAC1BW,cAAc,GAAGjB,iBAAiB,CAACe,CAAC,CAAC;MACrC,IAAIE,cAAc,GAAG,CAAC,EAAE;QACtBD,WAAW,GAAGjB,cAAc,CAACF,SAAS,CAAC;QACvC,IAAImB,WAAW,IAAI,CAAC,IAAI,CAACA,WAAW,GAAGC,cAAc,EAAE;UACrDF,CAAC,GAAGlB,SAAS;UACbU,iBAAiB,GAAG,KAAK;QAC3B;MACF;IACF;EACF;EACA,IAAID,QAAQ,KAAK,MAAM,EAAES,CAAC,GAAGb,iBAAiB,CAACa,CAAC,CAAC;EACjD,MAAMG,MAAM,GAAGd,KAAK,GAAGb,oBAAoB,CAAC;IAC1C4B,KAAK,EAAEX,CAAC;IACRL,QAAQ;IACRV,UAAU;IACVC,aAAa;IACbC;EACF,CAAC,CAAC,GAAGyB,SAAS;EACd,OAAO;IACLF,MAAM;IACNV,CAAC;IACDO,CAAC;IACDR;EACF,CAAC;AACH,CAAC;AAED,SAASf,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}