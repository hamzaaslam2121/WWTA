{"ast":null,"code":"import { useState, useRef, useCallback } from 'react';\nimport { ENTERED, startOrEnd, getEndStatus, PRE_EXIT, EXITING, getTimeout, nextTick, PRE_ENTER, ENTERING, getState } from './utils.js';\nconst initialStateMap = new Map();\nconst initialConfigMap = new Map();\nconst updateState = (key, status, setStateMap, latestStateMap, timeoutId, onChange) => {\n  clearTimeout(timeoutId);\n  const state = getState(status);\n  const stateMap = new Map(latestStateMap.current);\n  stateMap.set(key, state);\n  setStateMap(stateMap);\n  latestStateMap.current = stateMap;\n  onChange && onChange({\n    key,\n    current: state\n  });\n};\nconst useTransitionMap = ({\n  allowMultiple,\n  enter = true,\n  exit = true,\n  preEnter,\n  preExit,\n  timeout,\n  initialEntered,\n  mountOnEnter,\n  unmountOnExit,\n  onStateChange: onChange\n} = {}) => {\n  const [stateMap, setStateMap] = useState(initialStateMap);\n  const latestStateMap = useRef(stateMap);\n  const configMap = useRef(initialConfigMap);\n  const [enterTimeout, exitTimeout] = getTimeout(timeout);\n  const setItem = useCallback((key, config) => {\n    const {\n      initialEntered: _initialEntered = initialEntered\n    } = config || {};\n    const status = _initialEntered ? ENTERED : startOrEnd(mountOnEnter);\n    updateState(key, status, setStateMap, latestStateMap);\n    configMap.current.set(key, {});\n  }, [initialEntered, mountOnEnter]);\n  const deleteItem = useCallback(key => {\n    const newStateMap = new Map(latestStateMap.current);\n    if (newStateMap.delete(key)) {\n      setStateMap(newStateMap);\n      latestStateMap.current = newStateMap;\n      configMap.current.delete(key);\n      return true;\n    }\n    return false;\n  }, []);\n  const endTransition = useCallback(key => {\n    const stateObj = latestStateMap.current.get(key);\n    if (!stateObj) {\n      process.env.NODE_ENV !== 'production' && console.error(`[React-Transition-State] invalid key: ${key}`);\n      return;\n    }\n    const {\n      timeoutId\n    } = configMap.current.get(key);\n    const status = getEndStatus(stateObj._s, unmountOnExit);\n    status && updateState(key, status, setStateMap, latestStateMap, timeoutId, onChange);\n  }, [onChange, unmountOnExit]);\n  const toggle = useCallback((key, toEnter) => {\n    const stateObj = latestStateMap.current.get(key);\n    if (!stateObj) {\n      process.env.NODE_ENV !== 'production' && console.error(`[React-Transition-State] invalid key: ${key}`);\n      return;\n    }\n    const config = configMap.current.get(key);\n    const transitState = status => {\n      updateState(key, status, setStateMap, latestStateMap, config.timeoutId, onChange);\n      switch (status) {\n        case ENTERING:\n          if (enterTimeout >= 0) config.timeoutId = setTimeout(() => endTransition(key), enterTimeout);\n          break;\n        case EXITING:\n          if (exitTimeout >= 0) config.timeoutId = setTimeout(() => endTransition(key), exitTimeout);\n          break;\n        case PRE_ENTER:\n        case PRE_EXIT:\n          config.timeoutId = nextTick(transitState, status);\n          break;\n      }\n    };\n    const enterStage = stateObj.isEnter;\n    if (typeof toEnter !== 'boolean') toEnter = !enterStage;\n    if (toEnter) {\n      if (!enterStage) {\n        transitState(enter ? preEnter ? PRE_ENTER : ENTERING : ENTERED);\n        !allowMultiple && latestStateMap.current.forEach((_, _key) => _key !== key && toggle(_key, false));\n      }\n    } else {\n      if (enterStage) {\n        transitState(exit ? preExit ? PRE_EXIT : EXITING : startOrEnd(unmountOnExit));\n      }\n    }\n  }, [onChange, endTransition, allowMultiple, enter, exit, preEnter, preExit, enterTimeout, exitTimeout, unmountOnExit]);\n  const toggleAll = useCallback(toEnter => {\n    if (!allowMultiple && toEnter !== false) return;\n    for (const key of latestStateMap.current.keys()) toggle(key, toEnter);\n  }, [allowMultiple, toggle]);\n  return {\n    stateMap,\n    toggle,\n    toggleAll,\n    endTransition,\n    setItem,\n    deleteItem\n  };\n};\nexport { useTransitionMap };","map":{"version":3,"names":["useState","useRef","useCallback","ENTERED","startOrEnd","getEndStatus","PRE_EXIT","EXITING","getTimeout","nextTick","PRE_ENTER","ENTERING","getState","initialStateMap","Map","initialConfigMap","updateState","key","status","setStateMap","latestStateMap","timeoutId","onChange","clearTimeout","state","stateMap","current","set","useTransitionMap","allowMultiple","enter","exit","preEnter","preExit","timeout","initialEntered","mountOnEnter","unmountOnExit","onStateChange","configMap","enterTimeout","exitTimeout","setItem","config","_initialEntered","deleteItem","newStateMap","delete","endTransition","stateObj","get","process","env","NODE_ENV","console","error","_s","toggle","toEnter","transitState","setTimeout","enterStage","isEnter","forEach","_","_key","toggleAll","keys"],"sources":["/Users/hamzaaslam/VSCode/autode/client/node_modules/react-transition-state/dist/es/hooks/useTransitionMap.js"],"sourcesContent":["import { useState, useRef, useCallback } from 'react';\nimport { ENTERED, startOrEnd, getEndStatus, PRE_EXIT, EXITING, getTimeout, nextTick, PRE_ENTER, ENTERING, getState } from './utils.js';\n\nconst initialStateMap = new Map();\nconst initialConfigMap = new Map();\nconst updateState = (key, status, setStateMap, latestStateMap, timeoutId, onChange) => {\n  clearTimeout(timeoutId);\n  const state = getState(status);\n  const stateMap = new Map(latestStateMap.current);\n  stateMap.set(key, state);\n  setStateMap(stateMap);\n  latestStateMap.current = stateMap;\n  onChange && onChange({\n    key,\n    current: state\n  });\n};\nconst useTransitionMap = ({\n  allowMultiple,\n  enter = true,\n  exit = true,\n  preEnter,\n  preExit,\n  timeout,\n  initialEntered,\n  mountOnEnter,\n  unmountOnExit,\n  onStateChange: onChange\n} = {}) => {\n  const [stateMap, setStateMap] = useState(initialStateMap);\n  const latestStateMap = useRef(stateMap);\n  const configMap = useRef(initialConfigMap);\n  const [enterTimeout, exitTimeout] = getTimeout(timeout);\n  const setItem = useCallback((key, config) => {\n    const {\n      initialEntered: _initialEntered = initialEntered\n    } = config || {};\n    const status = _initialEntered ? ENTERED : startOrEnd(mountOnEnter);\n    updateState(key, status, setStateMap, latestStateMap);\n    configMap.current.set(key, {});\n  }, [initialEntered, mountOnEnter]);\n  const deleteItem = useCallback(key => {\n    const newStateMap = new Map(latestStateMap.current);\n    if (newStateMap.delete(key)) {\n      setStateMap(newStateMap);\n      latestStateMap.current = newStateMap;\n      configMap.current.delete(key);\n      return true;\n    }\n    return false;\n  }, []);\n  const endTransition = useCallback(key => {\n    const stateObj = latestStateMap.current.get(key);\n    if (!stateObj) {\n      process.env.NODE_ENV !== 'production' && console.error(`[React-Transition-State] invalid key: ${key}`);\n      return;\n    }\n    const {\n      timeoutId\n    } = configMap.current.get(key);\n    const status = getEndStatus(stateObj._s, unmountOnExit);\n    status && updateState(key, status, setStateMap, latestStateMap, timeoutId, onChange);\n  }, [onChange, unmountOnExit]);\n  const toggle = useCallback((key, toEnter) => {\n    const stateObj = latestStateMap.current.get(key);\n    if (!stateObj) {\n      process.env.NODE_ENV !== 'production' && console.error(`[React-Transition-State] invalid key: ${key}`);\n      return;\n    }\n    const config = configMap.current.get(key);\n    const transitState = status => {\n      updateState(key, status, setStateMap, latestStateMap, config.timeoutId, onChange);\n      switch (status) {\n        case ENTERING:\n          if (enterTimeout >= 0) config.timeoutId = setTimeout(() => endTransition(key), enterTimeout);\n          break;\n        case EXITING:\n          if (exitTimeout >= 0) config.timeoutId = setTimeout(() => endTransition(key), exitTimeout);\n          break;\n        case PRE_ENTER:\n        case PRE_EXIT:\n          config.timeoutId = nextTick(transitState, status);\n          break;\n      }\n    };\n    const enterStage = stateObj.isEnter;\n    if (typeof toEnter !== 'boolean') toEnter = !enterStage;\n    if (toEnter) {\n      if (!enterStage) {\n        transitState(enter ? preEnter ? PRE_ENTER : ENTERING : ENTERED);\n        !allowMultiple && latestStateMap.current.forEach((_, _key) => _key !== key && toggle(_key, false));\n      }\n    } else {\n      if (enterStage) {\n        transitState(exit ? preExit ? PRE_EXIT : EXITING : startOrEnd(unmountOnExit));\n      }\n    }\n  }, [onChange, endTransition, allowMultiple, enter, exit, preEnter, preExit, enterTimeout, exitTimeout, unmountOnExit]);\n  const toggleAll = useCallback(toEnter => {\n    if (!allowMultiple && toEnter !== false) return;\n    for (const key of latestStateMap.current.keys()) toggle(key, toEnter);\n  }, [allowMultiple, toggle]);\n  return {\n    stateMap,\n    toggle,\n    toggleAll,\n    endTransition,\n    setItem,\n    deleteItem\n  };\n};\n\nexport { useTransitionMap };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}